## Features  
The first thing I’m going to do is map out the core features I want my app to have. They are:  
- Managing viewbots on stream (count and actions);  
- Viewbots watching the stream;  
- Viewbots messaging in chat—preferably with contextual awareness, so interactions feel at least *halfway* authentic;  
- Viewbots interacting with polls. 
After clarifying these goals, I started diving deeper into research.
---
## Research  
### Kick Defense Mechanism  
Since messaging on Kick is only allowed for authorized users, I’ll also need:  
- Bot registration and authorization.  
This is where things get tricky. At first, I was surprised there’s no reCAPTCHA on the platform—but later I learned Kick uses the **Kasada** bot defense system. I found a helpful [paper](https://ru.scribd.com/document/899949744/Understanding-Kasada-Bot-Defense-and-Bypass-Mechanisms) on how it works.
I also discovered some tools addressing the account-generation problem, such as [this Kick.com account generator](https://github.com/fqw3/Kick.com-account-generator) and various [Kick bot projects](https://github.com/topics/kick-bot).  
Clearly, there *are* tools capable of bypassing Kasada—but most working implementations are locked behind paid APIs.
Fine. We’ll try it our own way.
My approach: automate a **headed browser**. This lets me bypass defenses that rely on WebGL fingerprinting, and any proof-of-work algorithms will execute naturally at runtime. It also reduces the need for heavy TLS tweaking (at least, I *think* it does). I might eventually add mouse-movement simulation—but that’s a detail for later.
To further obfuscate connections, I plan to route traffic through the **Tor network**. If allowed, this makes it nearly impossible for the server to trace the real client IP—reducing ban risk close to zero. It might also help with request rate–limiting, though I’m not yet sure whether Kick enforces that.
Another requirement for account creation: an **SMTP server** to fetch email verification codes, which bots can then use during signup.
Once logged in, I shouldn’t need to emulate anything beyond authentication: Kick’s API only requires a valid access token for most actions. Since they use a custom token format, I’m unsure about its lifespan—but I’ll store tokens securely and reuse them as needed.
### Watching Stream  
From browser DevTools, it seems viewer counts are incremented based on how many clients periodically send `ping` messages over the stream’s WebSocket connection.
The high-level viewing algorithm will be:
1. Obtain a JWT viewer token;  
2. Connect to the stream’s WebSocket using that token;  
3. Send a `ping` every 12–17 seconds.  
Crucially: **no verified account is required** to watch streams—only to chat or vote.
### Poll Answering  
Submitting poll responses is straightforward: just an API call from a verified account.  
The real question is *detection*: how do I reliably know when a poll appears? That’s still open.
### Chatting  
Chat interaction is significantly more complex than viewing or polling.
A truly *comprehensive* chat system would delegate viewer behavior to an LLM—deciding when and how each bot should act. That’s a major undertaking, so I’m shelving it for now.
Instead, I’ll start simple:  
- Chatters send messages periodically.  
- Message content is generated by an LLM based on context.
That context could include:
- Stream video frames (visual input),  
- Chat history,  
- Streamer’s real-time speech-to-text + emotion analysis.
For now, I’m *excluding* stream imagery due to processing overhead—it’s unlikely to yield much ROI on my modest hardware.
Thankfully, there are plenty of lightweight LLM options. I’ll run one locally via an **Ollama Docker container**, and can scale to a cloud-hosted model later if needed.
Real-time speech-to-text is also feasible—many modern STT solutions handle streaming input well.
My main concern is resource usage: will my laptop (especially with a game running in the background) handle concurrent STT, LLM inference, and browser automation? It might get expensive—CPU/GPU-wise.
The baseline interaction loop I’m considering:
1. Set a delay (e.g., 40 seconds),  
2. *During* the delay: generate a context-aware message,  
3. When the timer ends: send the message (or wait for generation if it’s not ready).  
Because generation happens *during* the delay, the resulting message lags ~40 seconds behind real-time context. Trade-off accepted—for now.
---
## System Design  

**Disclaimer**: I deeply respect the SOLID principles—especially as refined and popularized by Uncle Bob. That said, in practice, strict adherence can introduce so much abstraction (abstraction *on top of* abstraction) that code becomes unmaintainable for a *single* developer. SOLID and shine in team environments and long-term projects—but they aren’t always the right fit for solo, exploratory work.
Also, many principles feel *unnatural* in certain languages. For example: in dynamically typed Python, writing explicit interfaces (e.g., `Protocol` classes) to satisfy Dependency Inversion often slows development without proportional benefit.
I admire Clear Architecture though and think that *every* project should follow it's principles.
With that in mind—let’s return to system design.
### First Iteration  
See [[System design_0.canvas|first iteration]] for the architectural diagram.
Core entities:
- `Stream`: represents a session—holds target viewer count, start/stop controls, and stream metadata.  
- `Viewer`: an active bot instance—capable of watching, chatting, and voting.  
- `ViewersManager`: orchestrates viewers—scaling up/down to meet target counts, monitoring health, applying configs.  
- `AccountsManager`: unifies login, registration, and token management.
The [[System design_0.canvas|diagram]] is fairly self-explanatory, so I won’t over-explain it here.
 **Important**: This is an *abstract* plan. Expect significant iteration as implementation reveals real-world constraints.
# Next steps
From this state I'm considering further research and prototypes development on following topics:
- Connection obfuscation.
  I need to try and send few requests over tor network to see if this method works, and come up with other otherwise.
- Browser automation
  I need to explore browser automation and ways to simulate human behavior. It may include way more complex engineering than I assume.